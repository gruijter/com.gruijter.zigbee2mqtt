import { Zcl } from "zigbee-herdsman";
import type { DummyDevice, Fz, KeyValueAny, OnEvent, Tz, Zh } from "../lib/types";
import * as exposes from "./exposes";
export declare const legrandOptions: {
    manufacturerCode: Zcl.ManufacturerCode;
    disableDefaultResponse: boolean;
};
export declare const eLegrand: {
    identify: () => exposes.Enum;
    ledInDark: () => exposes.Binary;
    ledIfOn: () => exposes.Binary;
    getCover: (device: Zh.Device | DummyDevice) => exposes.Cover;
    getCalibrationModes: (isNLLVSwitch: boolean) => exposes.Enum;
};
export declare const readInitialBatteryState: OnEvent.Handler;
export declare const tzLegrand: {
    auto_mode: {
        key: string[];
        convertSet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, value: unknown, meta: Tz.Meta) => Promise<{
            state: {
                auto_mode: unknown;
            };
        }>;
    };
    calibration_mode: (isNLLVSwitch: boolean) => {
        key: string[];
        convertSet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, value: unknown, meta: Tz.Meta) => Promise<void>;
        convertGet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, meta: Tz.Meta) => Promise<void>;
    };
    led_mode: {
        key: string[];
        convertSet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, value: unknown, meta: Tz.Meta) => Promise<{
            state: {
                [x: string]: unknown;
            };
        }>;
        convertGet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, meta: Tz.Meta) => Promise<void>;
    };
    identify: {
        key: string[];
        options: exposes.Composite[];
        convertSet: (entity: import("zigbee-herdsman/dist/controller/model").Group | import("zigbee-herdsman/dist/controller/model").Endpoint, key: string, value: unknown, meta: Tz.Meta) => Promise<void>;
    };
};
export declare const fzLegrand: {
    calibration_mode: (isNLLVSwitch: boolean) => {
        cluster: "closuresWindowCovering";
        type: ["attributeReport", "readResponse"];
        convert: (model: import("../lib/types").Definition, msg: Fz.Message<"closuresWindowCovering", undefined, ["attributeReport", "readResponse"]>, publish: import("../lib/types").Publish, options: import("../lib/types").KeyValue, meta: Fz.Meta) => {
            calibration_mode: string;
        };
    };
    cluster_fc01: {
        cluster: "manuSpecificLegrandDevices";
        type: ["readResponse"];
        convert: (model: import("../lib/types").Definition, msg: Fz.Message<"manuSpecificLegrandDevices", undefined, ["readResponse"]>, publish: import("../lib/types").Publish, options: import("../lib/types").KeyValue, meta: Fz.Meta) => KeyValueAny;
    };
    stop_poll_on_checkin: {
        cluster: "genPollCtrl";
        type: ["commandCheckin"];
        convert: (model: import("../lib/types").Definition, msg: Fz.Message<"genPollCtrl", undefined, ["commandCheckin"]>, publish: import("../lib/types").Publish, options: import("../lib/types").KeyValue, meta: Fz.Meta) => void;
    };
    command_cover: {
        cluster: "closuresWindowCovering";
        type: ["attributeReport", "readResponse"];
        convert: (model: import("../lib/types").Definition, msg: Fz.Message<"closuresWindowCovering", undefined, ["attributeReport", "readResponse"]>, publish: import("../lib/types").Publish, options: import("../lib/types").KeyValue, meta: Fz.Meta) => KeyValueAny;
    };
    identify: {
        cluster: "genIdentify";
        type: ["attributeReport", "readResponse"];
        convert: (model: import("../lib/types").Definition, msg: Fz.Message<"genIdentify", undefined, ["attributeReport", "readResponse"]>, publish: import("../lib/types").Publish, options: import("../lib/types").KeyValue, meta: Fz.Meta) => {};
    };
};
//# sourceMappingURL=legrand.d.ts.map